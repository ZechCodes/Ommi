{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Ommi ORM!","text":"<p>Ommi is an OMM (Object Model Mapper) designed to simplify database interactions by covering the common 80% use case. It provides a consistent and intuitive interface, abstracting away the complexities of underlying database systems and drivers.</p> <p>Key Goals of Ommi:</p> <ul> <li>Simplicity: Get started quickly without needing deep database expertise.</li> <li>Consistency: Use the same API regardless of your chosen database (once a driver is available).</li> <li>Flexibility: Works seamlessly with popular data class libraries like Pydantic, attrs, and standard Python dataclasses.</li> </ul> <p>This documentation will guide you through installing Ommi, getting started with its features, and understanding how to leverage its capabilities in your projects.</p> <p>Focus on <code>Ommi</code>:</p> <p>It's important to note that Ommi is built with two levels of abstraction:</p> <ul> <li>Drivers: These are the lower-level components that communicate directly with specific databases. While essential, they are not the intended primary interface for most users.</li> <li><code>Ommi</code> Database Type: This is the higher-level, user-friendly interface that you will typically interact with. All examples and tutorials in this documentation will focus on using the <code>Ommi</code> object after it has been initialized with a driver.</li> </ul> <p>Ready to dive in? Head over to the Getting Started guide! </p>"},{"location":"getting-started/","title":"Getting Started with Ommi","text":"<p>This guide will walk you through the initial setup of Ommi in your project.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Ommi is available on PyPI and can be installed using Poetry (or pip). Since this project uses Poetry, you would typically add it to your <code>pyproject.toml</code>:</p> <pre><code>poetry add ommi\n</code></pre> <p>You will also need a driver for your target database. For example, to use SQLite (which is great for getting started):</p> <p><pre><code>poetry add ommi-sqlite # Or the specific package name for the SQLite driver if different\n</code></pre> You may need to install <code>ommi[sqlite]</code> if the driver is an extra.</p>"},{"location":"getting-started/#basic-setup","title":"Basic Setup","text":"<p>The core of using Ommi involves: 1. Defining your models using <code>@ommi_model()</code>. 2. Initializing an <code>Ommi</code> instance with a configured driver. 3. Ommi automatically handles the database schema (like creating tables) for your defined models when needed.</p> <p>Here's an example using an in-memory SQLite database:</p> <pre><code>import asyncio\nfrom dataclasses import dataclass\nfrom typing import Optional\n\nfrom ommi import Ommi, ommi_model\nfrom ommi.ext.drivers.sqlite import SQLiteDriver\n\n# 1. Define your models\n# Models decorated with @ommi_model() are automatically managed by Ommi.\n@ommi_model()\n@dataclass\nclass User:\n    id: int # Ommi typically infers primary keys from fields named 'id' or via Key metadata.\n    name: str\n    email: Optional[str] = None\n\nasync def main():\n    # 2. Initialize your chosen driver\n    driver = SQLiteDriver.connect()\n\n    # 3. Initialize Ommi with the driver\n    # The Ommi instance will manage the schema for models like User.\n    async with Ommi(driver) as db:\n        print(\"Ommi is ready. User table will be created automatically when needed.\")\n\n        # Now you can use `db` to interact with your database!\n        # The first operation on a model might trigger table creation if it doesn't exist.\n        new_user = User(id=1, name=\"Alice\", email=\"alice@example.com\")\n        await db.add(new_user).or_raise()\n        print(f\"Added user: {new_user}\")\n\n        retrieved_user = await db.find(User.id == 1).one.or_raise()\n        print(f\"Found user: {retrieved_user}\")\n\n        # Schema teardown for such automatically managed models is usually handled\n        # by the database connection lifecycle or specific driver features,\n        # especially for in-memory databases that are discarded on disconnect.\n        # For persistent databases, tables remain unless explicitly dropped.\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Important Notes:</p> <ul> <li>Async Operations: Ommi is designed for asynchronous programming.</li> <li>Automatic Schema Management (Default): When you define models with <code>@ommi_model()</code> (without specifying a <code>collection</code>), Ommi automatically handles their table creation as needed (e.g., on first use or when the <code>Ommi</code> instance is initialized). You generally don't need to call an explicit schema setup function for this default case.</li> <li>Explicit Collections: For more control over groups of models, especially in larger projects, you can use explicit <code>ModelCollection</code> instances. These require specific setup calls (e.g., <code>await db.use_models(your_collection)</code>). This is detailed in the Model Collections tutorial.</li> <li>Driver Specifics: Driver initialization and database behavior can vary.</li> <li>Focus on <code>Ommi</code>: All database operations are performed through the <code>Ommi</code> instance (<code>db</code>).</li> </ul> <p>Next, learn how to further define and work with Models. </p>"},{"location":"api/core/","title":"Core API","text":""},{"location":"api/core/#ommi.database.Ommi","title":"<code>ommi.database.Ommi</code>","text":"<p>Main class for interacting with a database through a specified driver.</p> <p>The <code>Ommi</code> class provides a high-level API for database operations, including adding, finding, updating, and deleting records, as well as managing database schemas and transactions. It is initialized with a database driver instance, which dictates how it communicates with the underlying database.</p> <p>Attributes:</p> Name Type Description <code>driver</code> <code>TDriver</code> <p>The database driver instance used for all operations.</p> Example Usage <pre><code>from ommi import Ommi, ommi_model\nfrom ommi.ext.drivers.sqlite import SQLiteDriver # Example driver\nfrom ommi.models.collections import ModelCollection\n\ncollection = ModelCollection()\n\n@ommi_model(collection=collection)\nclass User:\n    id: int\n    name: str\n\nasync def main():\n    driver = SQLiteDriver.connect()\n    async with Ommi(driver) as db:\n        await db.use_models(collection)\n        await db.add(User(name=\"Alice\")).or_raise()\n        user = await db.find(User.name == \"Alice\").one.or_raise()\n        print(f\"Found: {user.name}\")\n</code></pre>"},{"location":"api/core/#ommi.database.Ommi.__init__","title":"<code>__init__(driver, *, allow_imlicit_model_setup=True)</code>","text":"<p>Initializes the Ommi database interaction layer.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>TDriver</code> <p>The database driver instance (e.g., <code>SQLiteDriver</code>, <code>PostgreSQLDriver</code>) that Ommi will use to communicate with the database.</p> required <code>allow_imlicit_model_setup</code> <code>bool</code> <p>If <code>True</code> (the default), Ommi will attempt to automatically set up models from <code>ommi.models.collections.get_global_collection()</code> before the first operation if no models have been explicitly registered via <code>use_models()</code>. This can be convenient for simpler setups but might be undesirable in complex applications where explicit schema management is preferred. Set to <code>False</code> to disable this behavior and require explicit calls to <code>use_models()</code>.</p> <code>True</code>"},{"location":"api/core/#ommi.database.Ommi.add","title":"<code>add(*models)</code>","text":"<p>Persists one or more model instances to the database.</p> <p>This method takes new model instances and attempts to save them as new records. If implicit model setup is enabled and no models have been explicitly registered via <code>use_models()</code>, this method will trigger the setup of the global model collection.</p> <p>The result of the operation is wrapped in a <code>ommi.database.results.DBResult</code> type. This allows for explicit handling of the operation's success or failure: -   If successful, <code>DBResult.is_success</code> will be <code>True</code>, and <code>DBResult.value</code>     will contain the added model instance(s) (potentially updated with database-generated     values like primary keys). -   If an error occurs, <code>DBResult.is_failure</code> will be <code>True</code>, and     <code>DBResult.exception</code> will hold the specific exception.</p> <p>Parameters:</p> Name Type Description Default <code>*models</code> <code>DBModel</code> <p>A variable number of <code>DBModel</code> instances to be added to the      database. These should be new instances not yet persisted.</p> <code>()</code> <p>Returns:</p> Type Description <code>Awaitable[DBResult[DBModel]]</code> <p>An awaitable that resolves to a <code>DBResult</code>. The <code>DBResult</code> wraps the added</p> <code>Awaitable[DBResult[DBModel]]</code> <p>model(s) on success or the exception on failure.</p> Adding a single user <pre><code>from ommi.database.results import DBResult # For match/case\n\nuser = User(name=\"Alice\")\nresult_one = await db.add(user)\nif result_one.is_success:\n    added_user = result_one.value\n    print(f\"Added user: {added_user.name}\")\nelse:\n    print(f\"Failed to add user: {result_one.exception}\")\n</code></pre> Adding multiple users <pre><code>user1 = User(name=\"Alice\")\nuser2 = User(name=\"Bob\")\nresult_many = await db.add(user1, user2)\nif result_many.is_success:\n    added_items = result_many.value\n    print(f\"Successfully added {len(added_items)} users.\")\nelse:\n    print(f\"Failed to add multiple users: {result_many.exception}\")\n</code></pre>"},{"location":"api/core/#ommi.database.Ommi.find","title":"<code>find(*predicates)</code>","text":"<p>Initiates a query to retrieve models from the database based on specified criteria.</p> <p>This method provides a flexible way to define conditions for your search. It returns an <code>ommi.database.query_results.DBQueryResultBuilder</code> instance immediately. This builder object is central to fetching data and does not execute the query until one of its data retrieval or modification methods is called and awaited.</p> <p>If implicit model setup is enabled and no models have been explicitly registered via <code>use_models()</code>, this method will trigger the setup of the global model collection.</p> <p>Available <code>DBQueryResultBuilder</code> methods: -   <code>.all()</code>: Asynchronously fetches all matching records. On success, returns an     <code>AsyncBatchIterator</code> via <code>DBQueryResult.value</code>. -   <code>.one()</code>: Fetches a single record. On success, returns the record via <code>DBQueryResult.value</code>.     Raises <code>DBStatusNoResultException</code> (accessible via <code>DBQueryResult.exception</code>)     if no record is found. -   <code>.count()</code>: Returns the total number of matching records as an integer via     <code>DBQueryResult.value</code>. -   <code>.delete()</code>: Deletes all records matching the predicates. Returns a <code>DBResult</code>     indicating success or failure. -   <code>.update(**values)</code> or <code>.update(values_dict)</code>: Updates fields of matching records.     Returns a <code>DBResult</code> indicating success or failure.</p> <p>Each of these execution methods (<code>.all()</code>, <code>.one()</code>, etc.) returns an awaitable. When this awaitable is resolved, it yields an <code>ommi.database.query_results.DBQueryResult</code> (for <code>.all()</code>, <code>.one()</code>, <code>.count()</code>) or an <code>ommi.database.results.DBResult</code> (for <code>.delete()</code>, <code>.update()</code>), allowing robust outcome handling. The <code>DBQueryResultBuilder</code> itself can also be directly awaited, defaulting to <code>.all()</code>.</p> <p>Note on Predicates: Predicates define the search criteria. You can use: - Pythonic comparison expressions: <code>User.age &gt; 18</code> - <code>ommi.query_ast.when()</code> for complex AND/OR logic: <code>when(User.name == \"A\").Or(User.age &lt; 20)</code> - Model classes (e.g., <code>User</code>) to target all instances or provide context.</p> <p>Parameters:</p> Name Type Description Default <code>*predicates</code> <code>ASTGroupNode | DBModel | bool</code> <p>Variable number of conditions that define the query. These are typically combined with AND logic by default (internally passed to <code>ommi.query_ast.when(*predicates)</code>).</p> <code>()</code> <p>Returns:</p> Type Description <code>Awaitable[DBQueryResultBuilder[DBModel]]</code> <p>An awaitable that resolves to a <code>DBQueryResultBuilder</code>. This builder can then be</p> <code>Awaitable[DBQueryResultBuilder[DBModel]]</code> <p>used to execute the query and retrieve results in various forms.</p> Find user by ID <pre><code>from ommi.query_ast import when\nfrom ommi.database.query_results import DBQueryResult\nfrom ommi.database.results import DBResult, DBStatusNoResultException\n\nuser_id_to_find = 1\nquery_by_id = db.find(User.id == user_id_to_find)\nresult_status = await query_by_id.one()\n\nif result_status.is_success:\n    user = result_status.value\n    print(f\"Found user by ID: {user.name}\")\nelif result_status.exception_is(DBStatusNoResultException):\n    print(f\"User with ID {user_id_to_find} not found.\")\nelse:\n    print(f\"Error finding user by ID: {result_status.exception}\")\n</code></pre> Find users older than 18 and count them <pre><code>older_users_query = db.find(User.age &gt; 18, User.is_active == True)\ncount_status = await older_users_query.count()\nif count_status.is_success:\n    number_of_users = count_status.value\n    print(f\"Number of active users older than 18: {number_of_users}\")\nelse:\n    print(f\"Error counting users: {count_status.exception}\")\n</code></pre>"},{"location":"api/core/#ommi.database.Ommi.use_models","title":"<code>use_models(model_collection)</code>  <code>async</code>","text":"<p>Explicitly applies the schema for a given model collection to the database.</p> <p>This involves first attempting to delete any existing schema for the collection and then applying the new schema. This ensures that the database tables and indexes match the model definitions in the provided collection.</p> <p>This method should be called if <code>allow_implicit_model_setup</code> is <code>False</code> or if you need to manage different sets of models explicitly.</p> <p>Parameters:</p> Name Type Description Default <code>model_collection</code> <code>ModelCollection</code> <p>The <code>ModelCollection</code> instance whose schema (tables, indexes)               needs to be created or updated in the database.</p> required"},{"location":"api/core/#ommi.database.Ommi.remove_models","title":"<code>remove_models(model_collection)</code>  <code>async</code>","text":"<p>Removes the schema for the given model collection from the database.</p> <p>This typically involves dropping tables associated with the models in the collection. The collection is also removed from Ommi's set of known model collections.</p> <p>Parameters:</p> Name Type Description Default <code>model_collection</code> <code>ModelCollection</code> <p>The <code>ModelCollection</code> whose schema should be removed               from the database.</p> required"},{"location":"api/core/#ommi.database.Ommi.transaction","title":"<code>transaction()</code>","text":"<p>Creates an asynchronous context manager for database transactions.</p> <p>Operations performed on the <code>OmmiTransaction</code> object within the <code>async with</code> block will be part of a single atomic transaction. The transaction is automatically committed if the block exits successfully, or rolled back if an unhandled exception occurs within the block.</p> <p>Returns:</p> Type Description <code>OmmiTransaction</code> <p>An <code>OmmiTransaction</code> instance that can be used with <code>async with</code>.</p> Basic transaction usage <pre><code>async with db.transaction() as t:\n    await t.add(User(name=\"Charlie\"))\n    # If an error occurs here, changes are rolled back.\n    # If all operations succeed, changes are committed.\n</code></pre> Manual rollback within a transaction <pre><code>try:\n    async with db.transaction() as tx:\n        await tx.add(User(name=\"Dave\"))\n        if some_condition_fails:\n            await tx.rollback() # Explicitly roll back\n        else:\n            await tx.commit() # Explicitly commit (optional if auto-commit on exit is desired)\nexcept Exception as e:\n    print(f\"Transaction failed: {e}\")\n</code></pre>"},{"location":"api/core/#ommi.database.Ommi.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>This context manager ensures that the database connection is open when entering the <code>async with</code> block. Using a context manager ensures that exceptions are properly handled and resources are cleaned up automatically.</p> <p>Returns:</p> Type Description <p>The <code>Ommi</code> instance itself.</p>"},{"location":"api/core/#ommi.database.Ommi.__aexit__","title":"<code>__aexit__(*_)</code>  <code>async</code>","text":"<p>Exits the asynchronous context, closing the driver connection.</p> <p>Ensures that the database connection managed by the driver is properly closed when the <code>async with</code> block finishes, regardless of whether it completed successfully or an exception occurred.</p>"},{"location":"api/core/#ommi.database.OmmiTransaction","title":"<code>ommi.database.OmmiTransaction</code>","text":"<p>An asynchronous context manager for performing database operations within a transaction.</p> <p>This class wraps a driver-specific transaction (a <code>BaseDriverTransaction</code>) and provides a subset of the <code>Ommi</code> class's API (like <code>add</code>, <code>find</code>, etc.). All operations performed through an <code>OmmiTransaction</code> instance are executed within the context of the underlying database transaction.</p> <p>The transaction is automatically committed when the <code>async with</code> block is exited without an unhandled exception. If an exception occurs and propagates out of the block, the transaction is automatically rolled back.</p> Example <pre><code># Assuming `db` is an initialized Ommi instance\nasync with db.transaction() as t:\n    await t.add(MyModel(name=\"Example\"))\n    # Further operations like t.find(...), t.delete(...)\n    # If this block completes without error, changes are committed.\n    # If an error occurs, changes are rolled back.\n</code></pre>"},{"location":"api/core/#ommi.database.OmmiTransaction--warning","title":"Warning","text":"<p>Always use the methods on the <code>OmmiTransaction</code> instance itself (e.g., <code>t.add(...)</code>) when inside an <code>async with t:</code> block. Calling methods on the original <code>Ommi</code> instance from which the transaction was created will likely result in operations being performed outside the transaction's scope.</p>"},{"location":"api/core/#ommi.database.OmmiTransaction.transaction","title":"<code>transaction</code>  <code>property</code>","text":"<p>Provides access to the underlying driver-specific transaction object.</p> <p>While most operations should be performed via the <code>OmmiTransaction</code>'s own methods (like <code>add</code>, <code>find</code>), this property allows access to the raw driver transaction if needed for driver-specific functionalities not exposed directly by <code>OmmiTransaction</code>.</p> <p>Returns:</p> Type Description <code>BaseDriverTransaction</code> <p>The <code>BaseDriverTransaction</code> instance being wrapped.</p>"},{"location":"api/core/#ommi.database.OmmiTransaction.__init__","title":"<code>__init__(transaction)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>BaseDriverTransaction</code> <p>The driver-specific <code>BaseDriverTransaction</code> object that          this OmmiTransaction will manage.</p> required"},{"location":"api/core/#ommi.database.OmmiTransaction.add","title":"<code>add(*models)</code>","text":"<p>Adds one or more model instances to the database within the current transaction.</p> <p>This method delegates to the underlying driver transaction's <code>add</code> method. The behavior is analogous to <code>ommi.Ommi.add</code> but occurs within the transactional context.</p> <p>Parameters:</p> Name Type Description Default <code>*models</code> <code>DBModel</code> <p>The <code>DBModel</code> instances to be added.</p> <code>()</code> <p>Returns:</p> Type Description <code>Awaitable[DBResult[DBModel]]</code> <p>An awaitable that resolves to a <code>ommi.database.results.DBResult</code>.</p> <code>Awaitable[DBResult[DBModel]]</code> <p>This result object will contain the added models (potentially with updated,</p> <code>Awaitable[DBResult[DBModel]]</code> <p>database-generated fields like primary keys) on success, or an exception</p> <code>Awaitable[DBResult[DBModel]]</code> <p>on failure.</p>"},{"location":"api/core/#ommi.database.OmmiTransaction.find","title":"<code>find(*predicates)</code>","text":"<p>Initiates a query to find models in the database within the current transaction.</p> <p>This method delegates to the underlying driver transaction to build a query. It returns a <code>ommi.database.query_results.DBQueryResultBuilder</code>, allowing for fluent construction and execution of the query (e.g., <code>.all()</code>, <code>.one()</code>, <code>.count()</code>). The behavior is analogous to <code>ommi.Ommi.find</code> but occurs within the transactional context.</p> <p>Parameters:</p> Name Type Description Default <code>*predicates</code> <code>ASTGroupNode | DBModel | bool</code> <p>Query conditions, typically involving model fields or <code>ASTGroupNode</code>          instances created with <code>ommi.query_ast.when()</code>.</p> <code>()</code> <p>Returns:</p> Type Description <code>Awaitable[DBQueryResultBuilder[DBModel]]</code> <p>An awaitable that resolves to a <code>DBQueryResultBuilder</code> for executing the query</p> <code>Awaitable[DBQueryResultBuilder[DBModel]]</code> <p>within the transaction.</p>"},{"location":"api/core/#ommi.database.OmmiTransaction.use_models","title":"<code>use_models(model_collection)</code>  <code>async</code>","text":"<p>Applies the schema for a model collection within the current transaction.</p> <p>This involves deleting any existing schema for the collection and then applying the new one, all within the transaction's scope. If the transaction is later rolled back, these schema changes will also be reverted (if the database supports transactional DDL).</p> <p>Parameters:</p> Name Type Description Default <code>model_collection</code> <code>ModelCollection</code> <p>The <code>ModelCollection</code> whose schema needs to be applied.</p> required"},{"location":"api/core/#ommi.database.OmmiTransaction.remove_models","title":"<code>remove_models(model_collection)</code>  <code>async</code>","text":"<p>Removes the schema for a model collection from the database within the transaction.</p> <p>This operation is performed within the transaction's scope. If the transaction is rolled back, the schema removal may also be reverted (database-dependent).</p> <p>Parameters:</p> Name Type Description Default <code>model_collection</code> <code>ModelCollection</code> <p>The <code>ModelCollection</code> whose schema is to be removed.</p> required"},{"location":"api/core/#ommi.database.OmmiTransaction.commit","title":"<code>commit()</code>  <code>async</code>","text":"<p>Explicitly commits the current transaction.</p> <p>Once committed, all changes made within the transaction become permanent. It is often not necessary to call this directly, as the transaction will auto-commit upon successful exit from the <code>async with</code> block. However, it can be used for finer-grained control within the block.</p>"},{"location":"api/core/#ommi.database.OmmiTransaction.rollback","title":"<code>rollback()</code>  <code>async</code>","text":"<p>Explicitly rolls back the current transaction.</p> <p>This discards all changes made within the transaction since it began or since the last commit. If an exception occurs within the <code>async with</code> block, the transaction will typically auto-rollback, making direct calls to this method necessary only in specific control-flow scenarios.</p>"},{"location":"api/core/#ommi.database.OmmiTransaction.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Enters the asynchronous context, starting the underlying driver transaction.</p> <p>This method is called when entering an <code>async with</code> block. It delegates to the wrapped driver transaction, which typically starts a new transaction.</p> <p>Returns:</p> Type Description <p>The <code>OmmiTransaction</code> instance itself, allowing it to be used as the</p> <p>target of the <code>as</code> clause in the <code>async with</code> statement.</p>"},{"location":"api/core/#ommi.database.OmmiTransaction.__aexit__","title":"<code>__aexit__(exc_type, exc_val, exc_tb)</code>  <code>async</code>","text":"<p>Exits the asynchronous context, committing or rolling back the transaction.</p> <p>This method is called when exiting the <code>async with</code> block. It delegates to the wrapped driver transaction. Typically, the driver transaction will:</p> <ul> <li>Commit if <code>exc_type</code> is <code>None</code> (no exception occurred).</li> <li>Roll back if <code>exc_type</code> is not <code>None</code> (an exception occurred).</li> </ul>"},{"location":"api/drivers/","title":"Driver API","text":""},{"location":"api/drivers/#ommi.drivers.BaseDriver","title":"<code>ommi.drivers.BaseDriver</code>","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"api/drivers/#ommi.drivers.BaseDriver.connect","title":"<code>connect(settings=None)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Connects to the database.</p>"},{"location":"api/drivers/#ommi.drivers.BaseDriver.disconnect","title":"<code>disconnect()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Disconnects from the database.</p>"},{"location":"api/drivers/#ommi.drivers.BaseDriver.transaction","title":"<code>transaction()</code>  <code>abstractmethod</code>","text":"<p>Creates a transaction for the database.</p>"},{"location":"api/drivers/#ommi.drivers.BaseDriver.add","title":"<code>add(models)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Adds a series of models to the database and returns the models with their primary keys set.</p>"},{"location":"api/drivers/#ommi.drivers.BaseDriver.count","title":"<code>count(predicate)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Counts the number of models in the database that match the given predicate.</p>"},{"location":"api/drivers/#ommi.drivers.BaseDriver.delete","title":"<code>delete(predicate)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Deletes all models in the database that match the given predicate.</p>"},{"location":"api/drivers/#ommi.drivers.BaseDriver.fetch","title":"<code>fetch(predicate)</code>  <code>abstractmethod</code>","text":"<p>Fetches all models from the database that match the given predicate and returns them using an AsyncBatchIterator. This allows for efficient fetching of large datasets.</p>"},{"location":"api/drivers/#ommi.drivers.BaseDriver.update","title":"<code>update(predicate, values)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Updates all models in the database that match the given predicate with the given values.</p>"},{"location":"api/drivers/#ommi.drivers.BaseDriver.apply_schema","title":"<code>apply_schema(model_collection)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Applies the schema for the given model collection to the database.</p> <p>In the current version, schema evolution is not supported. If a model's schema differs from the existing database schema, an IncompatibleSchemaEvolutionError will be raised. To use a different schema, first call delete_schema().</p> <p>Parameters:</p> Name Type Description Default <code>model_collection</code> <code>ModelCollection</code> <p>The collection of models whose schema needs to be applied.</p> required <p>Raises:</p> Type Description <code>IncompatibleSchemaEvolutionError</code> <p>If the schema in the model collection differs from the existing schema in the database and schema evolution would be required.</p>"},{"location":"api/drivers/#ommi.drivers.BaseDriver.delete_schema","title":"<code>delete_schema(model_collection)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Deletes the schema for the given model collection from the database.</p>"},{"location":"api/drivers/#ommi.drivers.BaseDriverTransaction","title":"<code>ommi.drivers.BaseDriverTransaction</code>","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"api/drivers/#ommi.drivers.BaseDriverTransaction.close","title":"<code>close()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Closes the transaction to further changes.</p>"},{"location":"api/drivers/#ommi.drivers.BaseDriverTransaction.commit","title":"<code>commit()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Commits the transaction to the database.</p>"},{"location":"api/drivers/#ommi.drivers.BaseDriverTransaction.open","title":"<code>open()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Opens the transaction for changes.</p>"},{"location":"api/drivers/#ommi.drivers.BaseDriverTransaction.rollback","title":"<code>rollback()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Rolls back all changes to the database that have happened inside the transaction.</p>"},{"location":"api/drivers/#ommi.drivers.BaseDriverTransaction.add","title":"<code>add(models)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Adds a series of models to the database and returns the models with their primary keys set.</p>"},{"location":"api/drivers/#ommi.drivers.BaseDriverTransaction.count","title":"<code>count(predicate)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Counts the number of models in the database that match the given predicate.</p>"},{"location":"api/drivers/#ommi.drivers.BaseDriverTransaction.delete","title":"<code>delete(predicate)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Deletes all models in the database that match the given predicate.</p>"},{"location":"api/drivers/#ommi.drivers.BaseDriverTransaction.fetch","title":"<code>fetch(predicate)</code>  <code>abstractmethod</code>","text":"<p>Fetches all models from the database that match the given predicate and returns them using an AsyncBatchIterator. This allows for efficient fetching of large datasets.</p>"},{"location":"api/drivers/#ommi.drivers.BaseDriverTransaction.update","title":"<code>update(predicate, values)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Updates all models in the database that match the given predicate with the given values.</p>"},{"location":"api/drivers/#ommi.drivers.BaseDriverTransaction.apply_schema","title":"<code>apply_schema(model_collection)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Applies the schema for the given model collection to the database.</p> <p>In the current version, schema evolution is not supported. If a model's schema differs from the existing database schema, an IncompatibleSchemaEvolutionError will be raised. To use a different schema, first call delete_schema().</p> <p>Parameters:</p> Name Type Description Default <code>model_collection</code> <code>ModelCollection</code> <p>The collection of models whose schema needs to be applied.</p> required <p>Raises:</p> Type Description <code>IncompatibleSchemaEvolutionError</code> <p>If the schema in the model collection differs from the existing schema in the database and schema evolution would be required.</p>"},{"location":"api/drivers/#ommi.drivers.BaseDriverTransaction.delete_schema","title":"<code>delete_schema(model_collection)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Deletes the schema for the given model collection from the database.</p>"},{"location":"api/lazy_fields/","title":"Lazy Fields API","text":""},{"location":"api/lazy_fields/#ommi.models.query_fields.LazyQueryField","title":"<code>ommi.models.query_fields.LazyQueryField</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for fields that are populated via database queries.</p> <p>LazyQueryField provides the foundation for lazy-loaded relationship fields. Instead of loading related data when the model is fetched, these fields defer loading until the relationship is actually accessed, improving performance.</p> <p>Key features: - Caching of query results - Ability to refresh data from database - Handling of query errors - Support for default values</p>"},{"location":"api/lazy_fields/#ommi.models.query_fields.LazyQueryField.__init__","title":"<code>__init__(query_factory, driver=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>query_factory</code> <code>Callable[[], ASTGroupNode]</code> <p>Factory function that produces query AST nodes</p> required <code>driver</code> <code>AbstractDatabaseDriver | None</code> <p>Optional specific driver to use for queries (defaults to active driver)</p> <code>None</code>"},{"location":"api/lazy_fields/#ommi.models.query_fields.LazyQueryField.__await__","title":"<code>__await__()</code>","text":"<p>Make the field awaitable to fetch the related data.</p> <p>This allows using the field directly with await: <pre><code>related_models = await model.related_field\n</code></pre></p> <p>Returns:</p> Type Description <p>An awaitable that resolves to the related model(s)</p>"},{"location":"api/lazy_fields/#ommi.models.query_fields.LazyQueryField.or_use","title":"<code>or_use(default)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get the related model(s) or use a default value if fetching fails.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>D</code> <p>The value to return if fetching fails</p> required <p>Returns:</p> Type Description <code>T | D</code> <p>The related model(s) or the default value</p>"},{"location":"api/lazy_fields/#ommi.models.query_fields.LazyQueryField.refresh","title":"<code>refresh()</code>  <code>async</code>","text":"<p>Refresh the cached data by fetching from the database again.</p> <p>This forces a new database query regardless of existing cache state. Any errors during fetching will be stored in the cache.</p>"},{"location":"api/lazy_fields/#ommi.models.query_fields.LazyQueryField.refresh_if_needed","title":"<code>refresh_if_needed()</code>  <code>async</code>","text":"<p>Refresh the cached data only if it hasn't been fetched yet or previously failed.</p> <p>This is more efficient than unconditional refresh when the data may already be cached.</p>"},{"location":"api/lazy_fields/#ommi.models.query_fields.LazyQueryField.get_result","title":"<code>get_result()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get the DBResult containing either the related model(s) or an error.</p> <p>Returns:</p> Type Description <code>DBResult[T]</code> <p>A DBResult containing either the successful result or failure information</p>"},{"location":"api/lazy_fields/#ommi.models.query_fields.LazyQueryField.create","title":"<code>create(model, annotation_args, *, query_strategy=None)</code>  <code>classmethod</code>","text":"<p>Create a LazyQueryField instance from a model and type annotation.</p> <p>This factory method creates the appropriate LazyQueryField instance based on the model and annotation arguments.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>OmmiModel</code> <p>The model instance that owns the relationship</p> required <code>annotation_args</code> <code>tuple[Any, ...]</code> <p>Type annotation arguments for the relationship</p> required <code>query_strategy</code> <code>QueryStrategy | None</code> <p>Optional explicit query strategy to use</p> <code>None</code> <p>Returns:</p> Type Description <code>LazyQueryField</code> <p>A configured LazyQueryField instance</p>"},{"location":"api/lazy_fields/#ommi.models.query_fields.LazyLoadTheRelated","title":"<code>ommi.models.query_fields.LazyLoadTheRelated</code>","text":"<p>               Bases: <code>LazyQueryField</code></p> <p>A lazy-loaded field for one-to-one relationships.</p> <p>This field represents a relationship where the current model is related to a single instance of another model. The related model is loaded from the database only when accessed.</p> Example <pre><code>@ommi_model\nclass Post:\n    author_id: Annotated[int, ReferenceTo(User.id)]\n    author: LazyLoadTheRelated[User]\n</code></pre>"},{"location":"api/lazy_fields/#ommi.models.query_fields.LazyLoadTheRelated.or_use","title":"<code>or_use(default)</code>  <code>async</code>","text":"<p>Get the related model or use a default value if fetching fails.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>D</code> <p>The value to return if fetching fails</p> required <p>Returns:</p> Type Description <code>T | D</code> <p>The related model or the default value</p>"},{"location":"api/lazy_fields/#ommi.models.query_fields.LazyLoadTheRelated.get_result","title":"<code>get_result()</code>  <code>async</code>","text":"<p>Get the DBResult containing either the related model or an error.</p> <p>Returns:</p> Type Description <code>DBResult[T]</code> <p>A DBResult containing either the successful result or failure information</p>"},{"location":"api/lazy_fields/#ommi.models.query_fields.LazyLoadEveryRelated","title":"<code>ommi.models.query_fields.LazyLoadEveryRelated</code>","text":"<p>               Bases: <code>LazyQueryField</code></p> <p>A lazy-loaded field for one-to-many relationships.</p> <p>This field represents a relationship where the current model is related to multiple instances of another model. The related models are loaded from the database only when accessed.</p> Example <pre><code>@ommi_model\nclass User:\n    id: int\n    posts: LazyLoadEveryRelated[Post]\n</code></pre>"},{"location":"api/lazy_fields/#ommi.models.query_fields.LazyLoadEveryRelated.or_use","title":"<code>or_use(default)</code>  <code>async</code>","text":"<p>Get the related models or use a default value if fetching fails.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>list[D]</code> <p>The value to return if fetching fails</p> required <p>Returns:</p> Type Description <code>list[T] | list[D]</code> <p>A list of related models or the default value</p>"},{"location":"api/lazy_fields/#ommi.models.query_fields.LazyLoadEveryRelated.get_result","title":"<code>get_result()</code>  <code>async</code>","text":"<p>Get the DBResult containing either the related models or an error.</p> <p>Returns:</p> Type Description <code>DBResult[list[T]]</code> <p>A DBResult containing either the successful result list or failure information</p>"},{"location":"api/models/","title":"Models and Fields API","text":""},{"location":"api/models/#model-definition","title":"Model Definition","text":""},{"location":"api/models/#ommi.models.ommi_model","title":"<code>ommi.models.ommi_model(model_type=None, *, collection=None)</code>","text":"<pre><code>ommi_model(*, collection: ommi.models.collections.ModelCollection) -&gt; Callable[[Type[T]], Type[T] | Type[OmmiModel]]\n</code></pre><pre><code>ommi_model(model_type: Type[T]) -&gt; Type[T] | Type[OmmiModel]\n</code></pre> <p>Decorator that transforms a class into an Ommi model for database operations.</p> <p>This decorator analyzes a class's type annotations and field metadata, setting up the necessary infrastructure to use the class with Ommi database operations. It handles:</p> <ol> <li>Processing field annotations and metadata</li> <li>Setting up relationships between models</li> <li>Creating queryable descriptors for each field</li> <li>Registering the model with a model collection</li> </ol> <p>The decorated class inherits from OmmiModel, gaining access to methods like fetch(), count(), save(), reload(), and delete().</p> <p>Parameters:</p> Name Type Description Default <code>model_type</code> <code>Type[T] | None</code> <p>The class to transform into an Ommi model</p> <code>None</code> <code>collection</code> <code>ModelCollection | None</code> <p>Optional model collection to register the model with        (defaults to the global collection)</p> <code>None</code> <p>Returns:</p> Type Description <code>Type[T] | Callable[[Type[T]], Type[T]]</code> <p>The transformed model class or a decorator function if model_type is None</p> Example <pre><code>from dataclasses import dataclass\nfrom typing import Annotated\nfrom ommi import ommi_model, Key\n\n@ommi_model\n@dataclass\nclass User:\n    name: str\n    age: int\n    id: Annotated[int, Key] = None\n</code></pre>"},{"location":"api/models/#ommimodel-base-class","title":"OmmiModel Base Class","text":""},{"location":"api/models/#ommi.models.OmmiModel","title":"<code>ommi.models.OmmiModel</code>","text":"<p>Base class for all Ommi models, applied dynamically by the @ommi_model decorator.</p> <p>When a class is decorated with @ommi_model, the following changes occur:</p> <p>1. The class inherits from OmmiModel, gaining database operation methods like:</p> <ul> <li>fetch() - Query instances from the database</li> <li>save() - Persist changes to the database </li> <li>delete() - Remove from the database</li> <li>reload() - Refresh data from the database</li> <li>count() - Count matching instances</li> </ul> <p>2. Type annotations are processed to create queryable fields:</p> <ul> <li>Basic types (str, int, etc) become regular database columns</li> <li>Annotated types can specify special behaviors like Keys or References</li> <li>Forward references are supported for circular dependencies</li> <li>Fields can be used on the class type to build queries (e.g. User.age &gt;= 18)</li> </ul> <p>3. Relationship fields are transformed into lazy-loading descriptors:</p> <ul> <li>LazyLoadTheRelated[Model] for one-to-one relationships</li> <li>LazyLoadEveryRelated[Model] for one-to-many relationships</li> <li>Relationships are loaded from the database only when accessed</li> <li>Results are cached after first access</li> </ul> <p>4. Model metadata is created and stored in <code>__ommi__</code>:</p> <ul> <li>Field definitions and types</li> <li>Foreign key references</li> <li>Collection registration</li> <li>Model name and configuration</li> </ul> <p>Attributes:</p> Name Type Description <code>__ommi__</code> <code>OmmiMetadata</code> <p>Metadata about the model's fields, references and configuration</p> Basic Model Definition <p>Define a simple User model with an id, name, and age. <pre><code>@ommi_model\n@dataclass\nclass User:\n    id: Annotated[int, Key]\n    name: str\n    age: int\n</code></pre></p> Relationships <p>Define models with one-to-one and one-to-many relationships. <pre><code>@ommi_model\n@dataclass\nclass Post:\n    id: Annotated[int, Key]\n    title: str\n    content: str\n    author_id: Annotated[int, ReferenceTo(User.id)]\n    author: LazyLoadTheRelated[User]\n\n@ommi_model\n@dataclass\nclass User:\n    id: Annotated[int, Key]\n    name: str\n    posts: LazyLoadEveryRelated[Post]\n</code></pre></p> Query Building <p>Use class fields to construct complex queries. <pre><code>adult_users = await User.fetch(User.age &gt;= 18)\nrecent_posts = await Post.fetch(when(Post.author.name == \"Alice\").And(Post.created_at &gt; datetime(2023, 1, 1)))\n</code></pre></p> CRUD Operations <p>Perform create, read, update, and delete operations. <pre><code># Create\nnew_user = User(name=\"Bob\", age=30)\nawait new_user.save()\n\n# Read\nuser = await User.fetch(User.id == 1).one()\n\n# Update\nuser.age = 31\nawait user.save()\n\n# Delete\nawait user.delete()\n</code></pre></p> Lazy Loading <pre><code>user = await User.fetch(User.id == 1).one()\n# Posts are not loaded yet\nposts = await user.posts\n# Now posts are loaded and cached\n</code></pre>"},{"location":"api/models/#ommi.models.OmmiModel.get_driver","title":"<code>get_driver(driver=None)</code>","text":"<p>Get the database driver for this model class.</p> <p>This classmethod version can be called on the model class to get the appropriate database driver.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>DatabaseDrivers | None</code> <p>Optional specific driver to use</p> <code>None</code> <p>Returns:</p> Type Description <code>DatabaseDriver | None</code> <p>The appropriate database driver, or None if no driver is available</p>"},{"location":"api/models/#ommi.models.OmmiModel.delete","title":"<code>delete(driver=None)</code>","text":"<p>Delete this model instance from the database.</p> <p>This creates a delete action for the current model instance, which can be executed to remove it from the database.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>DatabaseDriver | None</code> <p>Optional specific driver to use</p> <code>None</code> <p>Returns:</p> Type Description <code>DeleteAction</code> <p>A DeleteAction that can be executed to perform the deletion</p> Example <pre><code># Delete a user\nuser = await User.fetch(User.name == \"Alice\").one()\nawait user.delete().raise_on_errors()\n</code></pre>"},{"location":"api/models/#ommi.models.OmmiModel.count","title":"<code>count(*predicates, columns=None, driver=None)</code>  <code>classmethod</code>","text":"<p>Count the number of model instances matching the given predicates.</p> <p>This creates a query to count models matching the specified conditions.</p> <p>Parameters:</p> Name Type Description Default <code>*predicates</code> <code>ASTGroupNode | DatabaseModel | bool</code> <p>Query conditions to filter the results</p> <code>()</code> <code>columns</code> <code>Any | None</code> <p>Optional column values to filter by</p> <code>None</code> <code>driver</code> <code>DatabaseDriver | None</code> <p>Optional specific driver to use</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncResultWrapper[int]</code> <p>An AsyncResultWrapper containing the count of matching models</p> Example <pre><code># Count users older than 30\ncount = await User.count(User.age &gt; 30).value\n</code></pre>"},{"location":"api/models/#ommi.models.OmmiModel.fetch","title":"<code>fetch(*predicates, driver=None, **columns)</code>  <code>classmethod</code>","text":"<p>Fetch model instances matching the given predicates.</p> <p>This creates a query to retrieve models matching the specified conditions.</p> <p>Parameters:</p> Name Type Description Default <code>*predicates</code> <code>ASTGroupNode | DatabaseModel | bool</code> <p>Query conditions to filter the results</p> <code>()</code> <code>driver</code> <code>DatabaseDriver | None</code> <p>Optional specific driver to use</p> <code>None</code> <code>**columns</code> <code>Any</code> <p>Column values to filter by (as keyword arguments)</p> <code>{}</code> <p>Returns:</p> Type Description <code>FetchAction[OmmiModel]</code> <p>A FetchAction that can be executed to retrieve the matching models</p> Example <pre><code># Fetch all users named \"Alice\"\nusers = await User.fetch(User.name == \"Alice\").all()\n\n# Alternative syntax with column values\nusers = await User.fetch(name=\"Alice\").all()\n</code></pre>"},{"location":"api/models/#ommi.models.OmmiModel.reload","title":"<code>reload(driver=None)</code>  <code>async</code>","text":"<p>Reload this model instance from the database.</p> <p>This refreshes the current instance with the latest data from the database, overwriting any local changes that haven't been saved.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>DatabaseDriver | None</code> <p>Optional specific driver to use</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The updated model instance (self)</p> Example <pre><code># Reload a user to get the latest data\nawait user.reload()\n</code></pre>"},{"location":"api/models/#ommi.models.OmmiModel.save","title":"<code>save(driver=None)</code>  <code>async</code>","text":"<p>Save changes to this model instance to the database.</p> <p>This updates the database record for this model with any changes made to the instance's fields.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>DatabaseDriver | None</code> <p>Optional specific driver to use</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the save was successful</p> Example <pre><code># Update a user's age and save\nuser.age = 31\nawait user.save()\n</code></pre>"},{"location":"api/models/#ommi.models.OmmiModel.get_primary_key_fields","title":"<code>get_primary_key_fields()</code>  <code>classmethod</code>","text":"<p>Get the primary key fields for this model.</p> <p>This determines which fields should be used as the primary key for database operations.</p> <p>Returns:</p> Type Description <code>tuple[FieldMetadata, ...]</code> <p>A tuple of FieldMetadata objects representing the primary key fields</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If no fields are defined on the model</p> Note <p>If no fields are explicitly marked as keys with the Key metadata, this will try to find fields named 'id' or '_id', then integer fields, and finally fall back to the first field.</p>"},{"location":"api/models/#field-metadata","title":"Field Metadata","text":""},{"location":"api/models/#ommi.models.field_metadata.FieldType","title":"<code>ommi.models.field_metadata.FieldType</code>","text":"<p>               Bases: <code>FieldMetadata</code></p> <p>Field metadata type for setting the field's data type.</p> <p>This metadata specifies how the field should be stored in the database, which may differ from its Python type.</p> <p>Attributes:</p> Name Type Description <code>field_type</code> <p>The database type for the field</p>"},{"location":"api/models/#ommi.models.field_metadata.FieldType.__init__","title":"<code>__init__(field_type)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>field_type</code> <code>Any</code> <p>The database type specification for the field</p> required"},{"location":"api/models/#ommi.models.field_metadata.StoreAs","title":"<code>ommi.models.field_metadata.StoreAs</code>","text":"<p>               Bases: <code>FieldMetadata</code></p> <p>Field metadata type for setting a custom storage name.</p> <p>This allows using a different field name in the database than in the model.</p> Example <pre><code>@ommi_model\n@dataclass\nclass User:\n    # Will be stored as \"user_name\" in the database\n    name: Annotated[str, StoreAs(\"user_name\")]\n</code></pre> <p>Attributes:</p> Name Type Description <code>store_as</code> <p>The name to use in the database</p>"},{"location":"api/models/#ommi.models.field_metadata.StoreAs.__init__","title":"<code>__init__(store_as)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>store_as</code> <code>str</code> <p>The name to use when storing the field in the database</p> required"},{"location":"api/models/#ommi.models.field_metadata.Auto","title":"<code>ommi.models.field_metadata.Auto = create_metadata_flag('Auto')</code>  <code>module-attribute</code>","text":""},{"location":"api/models/#ommi.models.field_metadata.Key","title":"<code>ommi.models.field_metadata.Key = create_metadata_flag('Key')</code>  <code>module-attribute</code>","text":""},{"location":"api/ommi_model/","title":"OmmiModel Base Class","text":""},{"location":"api/ommi_model/#ommi.models.OmmiModel","title":"<code>ommi.models.OmmiModel</code>","text":"<p>Base class for all Ommi models, applied dynamically by the @ommi_model decorator.</p> <p>When a class is decorated with @ommi_model, the following changes occur:</p> <p>1. The class inherits from OmmiModel, gaining database operation methods like:</p> <ul> <li>fetch() - Query instances from the database</li> <li>save() - Persist changes to the database </li> <li>delete() - Remove from the database</li> <li>reload() - Refresh data from the database</li> <li>count() - Count matching instances</li> </ul> <p>2. Type annotations are processed to create queryable fields:</p> <ul> <li>Basic types (str, int, etc) become regular database columns</li> <li>Annotated types can specify special behaviors like Keys or References</li> <li>Forward references are supported for circular dependencies</li> <li>Fields can be used on the class type to build queries (e.g. User.age &gt;= 18)</li> </ul> <p>3. Relationship fields are transformed into lazy-loading descriptors:</p> <ul> <li>LazyLoadTheRelated[Model] for one-to-one relationships</li> <li>LazyLoadEveryRelated[Model] for one-to-many relationships</li> <li>Relationships are loaded from the database only when accessed</li> <li>Results are cached after first access</li> </ul> <p>4. Model metadata is created and stored in <code>__ommi__</code>:</p> <ul> <li>Field definitions and types</li> <li>Foreign key references</li> <li>Collection registration</li> <li>Model name and configuration</li> </ul> <p>Attributes:</p> Name Type Description <code>__ommi__</code> <code>OmmiMetadata</code> <p>Metadata about the model's fields, references and configuration</p> Basic Model Definition <p>Define a simple User model with an id, name, and age. <pre><code>@ommi_model\n@dataclass\nclass User:\n    id: Annotated[int, Key]\n    name: str\n    age: int\n</code></pre></p> Relationships <p>Define models with one-to-one and one-to-many relationships. <pre><code>@ommi_model\n@dataclass\nclass Post:\n    id: Annotated[int, Key]\n    title: str\n    content: str\n    author_id: Annotated[int, ReferenceTo(User.id)]\n    author: LazyLoadTheRelated[User]\n\n@ommi_model\n@dataclass\nclass User:\n    id: Annotated[int, Key]\n    name: str\n    posts: LazyLoadEveryRelated[Post]\n</code></pre></p> Query Building <p>Use class fields to construct complex queries. <pre><code>adult_users = await User.fetch(User.age &gt;= 18)\nrecent_posts = await Post.fetch(when(Post.author.name == \"Alice\").And(Post.created_at &gt; datetime(2023, 1, 1)))\n</code></pre></p> CRUD Operations <p>Perform create, read, update, and delete operations. <pre><code># Create\nnew_user = User(name=\"Bob\", age=30)\nawait new_user.save()\n\n# Read\nuser = await User.fetch(User.id == 1).one()\n\n# Update\nuser.age = 31\nawait user.save()\n\n# Delete\nawait user.delete()\n</code></pre></p> Lazy Loading <pre><code>user = await User.fetch(User.id == 1).one()\n# Posts are not loaded yet\nposts = await user.posts\n# Now posts are loaded and cached\n</code></pre>"},{"location":"api/ommi_model/#ommi.models.OmmiModel.get_driver","title":"<code>get_driver(driver=None)</code>","text":"<p>Get the database driver for this model class.</p> <p>This classmethod version can be called on the model class to get the appropriate database driver.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>DatabaseDrivers | None</code> <p>Optional specific driver to use</p> <code>None</code> <p>Returns:</p> Type Description <code>DatabaseDriver | None</code> <p>The appropriate database driver, or None if no driver is available</p>"},{"location":"api/ommi_model/#ommi.models.OmmiModel.delete","title":"<code>delete(driver=None)</code>","text":"<p>Delete this model instance from the database.</p> <p>This creates a delete action for the current model instance, which can be executed to remove it from the database.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>DatabaseDriver | None</code> <p>Optional specific driver to use</p> <code>None</code> <p>Returns:</p> Type Description <code>DeleteAction</code> <p>A DeleteAction that can be executed to perform the deletion</p> Example <pre><code># Delete a user\nuser = await User.fetch(User.name == \"Alice\").one()\nawait user.delete().raise_on_errors()\n</code></pre>"},{"location":"api/ommi_model/#ommi.models.OmmiModel.count","title":"<code>count(*predicates, columns=None, driver=None)</code>  <code>classmethod</code>","text":"<p>Count the number of model instances matching the given predicates.</p> <p>This creates a query to count models matching the specified conditions.</p> <p>Parameters:</p> Name Type Description Default <code>*predicates</code> <code>ASTGroupNode | DatabaseModel | bool</code> <p>Query conditions to filter the results</p> <code>()</code> <code>columns</code> <code>Any | None</code> <p>Optional column values to filter by</p> <code>None</code> <code>driver</code> <code>DatabaseDriver | None</code> <p>Optional specific driver to use</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncResultWrapper[int]</code> <p>An AsyncResultWrapper containing the count of matching models</p> Example <pre><code># Count users older than 30\ncount = await User.count(User.age &gt; 30).value\n</code></pre>"},{"location":"api/ommi_model/#ommi.models.OmmiModel.fetch","title":"<code>fetch(*predicates, driver=None, **columns)</code>  <code>classmethod</code>","text":"<p>Fetch model instances matching the given predicates.</p> <p>This creates a query to retrieve models matching the specified conditions.</p> <p>Parameters:</p> Name Type Description Default <code>*predicates</code> <code>ASTGroupNode | DatabaseModel | bool</code> <p>Query conditions to filter the results</p> <code>()</code> <code>driver</code> <code>DatabaseDriver | None</code> <p>Optional specific driver to use</p> <code>None</code> <code>**columns</code> <code>Any</code> <p>Column values to filter by (as keyword arguments)</p> <code>{}</code> <p>Returns:</p> Type Description <code>FetchAction[OmmiModel]</code> <p>A FetchAction that can be executed to retrieve the matching models</p> Example <pre><code># Fetch all users named \"Alice\"\nusers = await User.fetch(User.name == \"Alice\").all()\n\n# Alternative syntax with column values\nusers = await User.fetch(name=\"Alice\").all()\n</code></pre>"},{"location":"api/ommi_model/#ommi.models.OmmiModel.reload","title":"<code>reload(driver=None)</code>  <code>async</code>","text":"<p>Reload this model instance from the database.</p> <p>This refreshes the current instance with the latest data from the database, overwriting any local changes that haven't been saved.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>DatabaseDriver | None</code> <p>Optional specific driver to use</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The updated model instance (self)</p> Example <pre><code># Reload a user to get the latest data\nawait user.reload()\n</code></pre>"},{"location":"api/ommi_model/#ommi.models.OmmiModel.save","title":"<code>save(driver=None)</code>  <code>async</code>","text":"<p>Save changes to this model instance to the database.</p> <p>This updates the database record for this model with any changes made to the instance's fields.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>DatabaseDriver | None</code> <p>Optional specific driver to use</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the save was successful</p> Example <pre><code># Update a user's age and save\nuser.age = 31\nawait user.save()\n</code></pre>"},{"location":"api/ommi_model/#ommi.models.OmmiModel.get_primary_key_fields","title":"<code>get_primary_key_fields()</code>  <code>classmethod</code>","text":"<p>Get the primary key fields for this model.</p> <p>This determines which fields should be used as the primary key for database operations.</p> <p>Returns:</p> Type Description <code>tuple[FieldMetadata, ...]</code> <p>A tuple of FieldMetadata objects representing the primary key fields</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If no fields are defined on the model</p> Note <p>If no fields are explicitly marked as keys with the Key metadata, this will try to find fields named 'id' or '_id', then integer fields, and finally fall back to the first field.</p>"},{"location":"api/overview/","title":"API Reference Overview","text":"<p>Welcome to the API reference for Ommi. This section provides detailed documentation for the various components of the Ommi library.</p> <p>Please use the navigation to explore the different modules and classes:</p> <ul> <li>Core: Core <code>Ommi</code> class and transaction management.</li> <li>Drivers: Base classes for database drivers.</li> <li>Models: Decorators and metadata for defining Ommi models.</li> <li>Results: Classes for handling database operation results.</li> <li>Lazy Fields: Types for defining and using lazy-loaded fields. </li> </ul>"},{"location":"api/results/","title":"Results API","text":""},{"location":"api/results/#ommi.database.results.DBResult","title":"<code>ommi.database.results.DBResult</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for representing the outcome of a single database operation.</p> <p>Provides a structured way (<code>DBSuccess</code>, <code>DBFailure</code>) to handle results or errors from operations like adding a record or a simple update/delete confirmation. Supports Python's <code>match/case</code> for pattern matching.</p> Class Attributes <p>DBSuccess (Type[DBSuccess[T]]): Reference to the <code>DBSuccess</code> class. DBFailure (Type[DBFailure[T]]): Reference to the <code>DBFailure</code> class.</p>"},{"location":"api/results/#ommi.database.results.DBResult.result","title":"<code>result</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>The successful result of the operation.</p> <p>Raises:</p> Type Description <code>DBStatusNoResultException</code> <p>If called on <code>DBFailure</code>.</p>"},{"location":"api/results/#ommi.database.results.DBResult.exception","title":"<code>exception</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>The exception from a failed operation.</p> <p>Raises:</p> Type Description <code>DBStatusNoResultException</code> <p>If called on <code>DBSuccess</code>.</p>"},{"location":"api/results/#ommi.database.results.DBResult.__init_subclass__","title":"<code>__init_subclass__(**kwargs)</code>","text":"<p>Registers <code>DBSuccess</code> and <code>DBFailure</code> subclasses for pattern matching convenience.</p>"},{"location":"api/results/#ommi.database.results.DBResult.result_or","title":"<code>result_or(default)</code>  <code>abstractmethod</code>","text":"<p>Returns the operation result if successful, else a default.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>D</code> <p>Value to return if the operation failed.</p> required <p>Returns:</p> Type Description <code>T | D</code> <p>The result or the default.</p>"},{"location":"api/results/#ommi.database.results.DBResult.exception_or","title":"<code>exception_or(default)</code>  <code>abstractmethod</code>","text":"<p>Returns the exception if the operation failed, else a default.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>D</code> <p>Value to return if the operation was successful.</p> required <p>Returns:</p> Type Description <code>Exception | D</code> <p>The exception or the default.</p>"},{"location":"api/results/#ommi.database.results.DBResult.build","title":"<code>build(callback, *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a <code>DBResultBuilder</code> to execute a callback and wrap its outcome.</p> <p>This factory method is the primary way <code>DBResultBuilder</code> instances are created internally within Ommi (e.g., by <code>Ommi.add</code>). It prepares an awaitable operation to be executed such that its result or exception is captured in a <code>DBResult</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[P, Awaitable[T]]</code> <p>An asynchronous function (awaitable callable) to be executed.</p> required <code>*args</code> <code>args</code> <p>Positional arguments to pass to the <code>callback</code>.</p> <code>()</code> <code>**kwargs</code> <code>kwargs</code> <p>Keyword arguments to pass to the <code>callback</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DBResultBuilder[T]</code> <p>A <code>DBResultBuilder[T]</code> instance, ready to be awaited.</p>"},{"location":"api/results/#ommi.database.query_results.DBQueryResult","title":"<code>ommi.database.query_results.DBQueryResult</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for representing the outcome of a database query.</p> <p>This class, along with its concrete subclasses <code>DBQuerySuccess</code> and <code>DBQueryFailure</code>, provides a structured way to handle the results of data retrieval operations. It supports Python's <code>match/case</code> statement for pattern matching on query outcomes.</p> <p>The <code>__match_args__</code> are defined to allow matching on <code>result</code> (for success) or <code>exception</code> (for failure).</p> Class Attributes <p>DBQuerySuccess (Type[DBQuerySuccess[T]]): A reference to the <code>DBQuerySuccess</code> class.     Automatically populated by <code>__init_subclass__</code>. DBQueryFailure (Type[DBQueryFailure[T]]): A reference to the <code>DBQueryFailure</code> class.     Automatically populated by <code>__init_subclass__</code>.</p>"},{"location":"api/results/#ommi.database.query_results.DBQueryResult.result","title":"<code>result</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>The successful result of the query.</p> <p>Raises:</p> Type Description <code>DBStatusNoResultException</code> <p>If accessed on <code>DBQueryFailure</code>, as there is no result.</p>"},{"location":"api/results/#ommi.database.query_results.DBQueryResult.exception","title":"<code>exception</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>The exception that occurred during a failed query.</p> <p>Raises:</p> Type Description <code>DBStatusNoResultException</code> <p>If called on <code>DBQuerySuccess</code>, as there is no exception.</p>"},{"location":"api/results/#ommi.database.query_results.DBQueryResult.__init_subclass__","title":"<code>__init_subclass__(**kwargs)</code>","text":"<p>Registers concrete subclasses <code>DBQuerySuccess</code> and <code>DBQueryFailure</code> as class attributes.</p> <p>This allows for convenient access and eliminates the need to import all three classes. You can access them as <code>DBQueryResult.DBQuerySuccess</code> which enables pattern matching like: <pre><code>from ommi import DBQueryResult\n...\nmatch await db.find(User.id == 1).one():\n    case DBQueryResult.DBQuerySuccess(user):\n        print(user)\n    case DBQueryResult.DBQueryFailure(exc):\n        print(f\"Error: {exc}\")\n</code></pre></p>"},{"location":"api/results/#ommi.database.query_results.DBQueryResult.result_or","title":"<code>result_or(default)</code>  <code>abstractmethod</code>","text":"<p>Returns the query result if successful, otherwise returns the provided default.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>D</code> <p>The value to return if the query failed or yielded no specific result value.</p> required <p>Returns:</p> Type Description <code>T | D</code> <p>The query result or the default value.</p>"},{"location":"api/results/#ommi.database.query_results.DBQueryResult.exception_or","title":"<code>exception_or(default)</code>  <code>abstractmethod</code>","text":"<p>Returns the exception if the query failed, otherwise returns the provided default.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>D</code> <p>The value to return if the query was successful (i.e., no exception).</p> required <p>Returns:</p> Type Description <code>Exception | D</code> <p>The exception object or the default value.</p>"},{"location":"api/results/#ommi.database.query_results.DBQueryResult.build","title":"<code>build(driver, predicate)</code>  <code>classmethod</code>","text":"<p>Creates a <code>DBQueryResultBuilder</code> for the given driver and predicate.</p> <p>This is the typical entry point for constructing a query that will eventually yield a <code>DBQueryResult</code>. It's used internally by <code>Ommi.find()</code> and <code>OmmiTransaction.find()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>BaseDriver</code> <p>The database driver instance to be used for executing the query.</p> required <code>predicate</code> <code>ASTGroupNode</code> <p>An <code>ASTGroupNode</code> representing the query conditions.</p> required <p>Returns:</p> Type Description <code>DBQueryResultBuilder[T]</code> <p>A <code>DBQueryResultBuilder</code> instance, ready to have an execution method</p> <code>DBQueryResultBuilder[T]</code> <p>(e.g., <code>.all()</code>, <code>.one()</code>) called on it.</p>"},{"location":"usage/association-tables/","title":"Using Association Tables for Many-to-Many Relationships","text":"<p>Many-to-many relationships (e.g., a <code>Student</code> can enroll in multiple <code>Courses</code>, and a <code>Course</code> can have many <code>Students</code>) are typically modeled using an intermediary association table (or join table).</p> <p>Ommi handles this by combining Query Fields with an explicit association model. You use <code>LazyLoadEveryRelated</code> along with <code>typing.Annotated</code> and <code>ommi.models.query_fields.AssociateUsing</code> to define these relationships.</p>"},{"location":"usage/association-tables/#defining-models-for-a-many-to-many-relationship","title":"Defining Models for a Many-to-Many Relationship","text":"<p>You'll define three models: 1.  The first primary model (e.g., <code>Post</code>). 2.  The second primary model (e.g., <code>Tag</code>). 3.  The association model that links them (e.g., <code>PostTag</code>), which contains foreign keys to <code>Post</code> and <code>Tag</code>.</p> <p>Example from Ommi's tests (adapted for Post/Tag scenario):</p> <p>Imagine <code>Post</code>s can have multiple <code>Tag</code>s, and <code>Tag</code>s can be applied to multiple <code>Post</code>s.</p> <pre><code>import asyncio\nfrom dataclasses import dataclass\nfrom typing import Annotated, List, Optional\n\nfrom ommi import Ommi, ommi_model\nfrom ommi.models.collections import ModelCollection\nfrom ommi.models.field_metadata import ReferenceTo\nfrom ommi.models.query_fields import AssociateUsing, LazyLoadEveryRelated\nfrom ommi.query_ast import when # Not strictly needed for M2M definition, but good for other queries\nfrom ommi.ext.drivers.sqlite import SQLiteDriver\n\napp_models = ModelCollection()\n\n@ommi_model(collection=app_models)\n@dataclass\nclass Post:\n    id: int\n    title: str\n\n    # Query Field for fetching all related Tags for this Post\n    # It uses LazyLoadEveryRelated with an Annotated type.\n    # AssociateUsing(PostTag) tells Ommi to use the PostTag model as the intermediary.\n    # Ommi infers the join conditions from the foreign keys in PostTag.\n    tags: \"LazyLoadEveryRelated[Annotated[Tag, AssociateUsing(PostTag)]]\"\n\n@ommi_model(collection=app_models)\n@dataclass\nclass Tag:\n    id: int\n    name: str\n\n    # Optional: Define the reverse relationship from Tag to Post\n    # posts: \"LazyLoadEveryRelated[Annotated[Post, AssociateUsing(PostTag)]]\"\n\n@ommi_model(collection=app_models)\n@dataclass\nclass PostTag: # The Association Table\n    # By convention, Ommi might use fields like 'post_id' and 'tag_id'\n    # to understand the links if ReferenceTo is more complex for M2M linking fields.\n    # The test_query_fields.py example uses ReferenceTo(ModelA.id) directly in the association table.\n    post_id: Annotated[int, ReferenceTo(Post.id)]\n    tag_id: Annotated[int, ReferenceTo(Tag.id)]\n    # You can add other fields to the association table, e.g., timestamp\n    created_at: Optional[str] = None\n\n    # Ommi might require a way to specify composite primary keys if 'post_id' and 'tag_id' together form one.\n    # For now, assume Ommi handles this or they are just indexed.\n\n\nasync def demo_many_to_many():\n    driver = SQLiteDriver.connect()\n    async with Ommi(driver) as db:\n        await app_models.setup_on(db) # Creates Post, Tag, PostTag tables\n\n        # Create data\n        post1 = Post(id=1, title=\"Ommi is Great\")\n        post2 = Post(id=2, title=\"Python Tips\")\n        tag_ommi = Tag(id=101, name=\"ommi\")\n        tag_python = Tag(id=102, name=\"python\")\n        tag_guide = Tag(id=103, name=\"guide\")\n\n        await db.add(post1, post2, tag_ommi, tag_python, tag_guide).or_raise()\n\n        # Create associations in PostTag table\n        # Post1 is tagged with \"ommi\" and \"guide\"\n        await db.add(\n            PostTag(post_id=post1.id, tag_id=tag_ommi.id, created_at=\"2024-01-01\"),\n            PostTag(post_id=post1.id, tag_id=tag_guide.id, created_at=\"2024-01-01\")\n        ).or_raise()\n\n        # Post2 is tagged with \"python\" and \"guide\"\n        await db.add(\n            PostTag(post_id=post2.id, tag_id=tag_python.id, created_at=\"2024-01-02\"),\n            PostTag(post_id=post2.id, tag_id=tag_guide.id, created_at=\"2024-01-02\")\n        ).or_raise()\n\n        # --- Lazily load tags for a post ---\n        retrieved_post1 = await db.find(Post.id == 1).one.or_raise()\n        print(f\"Post: '{retrieved_post1.title}'\")\n\n        print(\"Loading tags for Post 1...\")\n        post1_tags = await retrieved_post1.tags # This triggers the lazy load\n\n        print(f\"Tags for '{retrieved_post1.title}':\")\n        for tag in post1_tags:\n            print(f\"- {tag.name}\")\n\n        # --- (Optional) Lazily load posts for a tag (if reverse relationship is defined) ---\n        # retrieved_tag_guide = await db.find(Tag.id == tag_guide.id).one.or_raise()\n        # print(f\"\\nTag: '{retrieved_tag_guide.name}'\")\n        # print(f\"Loading posts for Tag '{retrieved_tag_guide.name}'...\")\n        # guide_posts = await retrieved_tag_guide.posts\n        # print(f\"Posts tagged with '{retrieved_tag_guide.name}':\")\n        # for post in guide_posts:\n        #     print(f\"- {post.title}\")\n\n        await app_models.remove_from(db)\n\n# To run:\n# if __name__ == \"__main__\":\n#     asyncio.run(demo_many_to_many())\n</code></pre>"},{"location":"usage/association-tables/#how-ommi-handles-many-to-many","title":"How Ommi Handles Many-to-Many","text":"<ol> <li>Association Model (<code>PostTag</code>): This model is crucial. It explicitly defines the links between <code>Post</code> and <code>Tag</code> using foreign keys (defined with <code>Annotated[int, ReferenceTo(Model.id)]</code>).</li> <li>Query Field on Primary Model (<code>Post.tags</code>):<ul> <li>It's typed with <code>LazyLoadEveryRelated</code> because a post can have multiple tags.</li> <li>Inside <code>LazyLoadEveryRelated</code>, <code>Annotated[Tag, AssociateUsing(PostTag)]</code> is used.<ul> <li><code>Tag</code>: Specifies that the query field will return instances of <code>Tag</code>.</li> <li><code>AssociateUsing(PostTag)</code>: Tells Ommi that <code>PostTag</code> is the intermediary table to use for resolving this relationship.</li> </ul> </li> </ul> </li> <li>Lazy Loading: When you <code>await post_instance.tags</code>, Ommi:<ul> <li>Identifies <code>post_instance</code> (e.g., Post with id=1).</li> <li>Looks at the <code>PostTag</code> table.</li> <li>Finds all <code>PostTag</code> records where <code>post_id</code> matches <code>post_instance.id</code>.</li> <li>For each of these <code>PostTag</code> records, it takes the <code>tag_id</code>.</li> <li>It then fetches all <code>Tag</code> models corresponding to these <code>tag_id</code>s.</li> <li>Returns a list of these <code>Tag</code> instances.</li> </ul> </li> </ol> <p>This provides a declarative way to define complex many-to-many relationships, with Ommi handling the underlying join logic through the association table when the query field is awaited.</p>"},{"location":"usage/association-tables/#key-aspects","title":"Key Aspects","text":"<ul> <li>Explicit Association Model: You must define the association model (e.g., <code>PostTag</code>). This model can also hold additional attributes about the relationship itself (e.g., <code>created_at</code> timestamp).</li> <li><code>AssociateUsing</code>: This is the key to linking the <code>LazyLoadEveryRelated</code> query field to the correct association table.</li> <li><code>ReferenceTo</code>: Used in the association model to define the foreign keys linking back to the primary models.</li> <li>Bidirectional Relationships: You can define the relationship on both sides (e.g., <code>Post.tags</code> and <code>Tag.posts</code>) using the same <code>AssociateUsing(PostTag)</code> mechanism.</li> </ul> <p>This approach keeps your model definitions clean while leveraging Ommi's query field system for efficient, lazy-loaded data retrieval for many-to-many relationships. </p>"},{"location":"usage/handling-results/","title":"Handling Database Operation Results","text":"<p>Ommi provides robust result types like <code>DBResult[T]</code> and <code>DBQueryResult[T]</code> that allow you to explicitly handle the outcome of database operations, such as success or failure, without immediately resorting to <code>try/except</code> blocks or methods like <code>.or_raise()</code>.</p> <p>This approach, often used with Python's <code>match/case</code> statement, promotes clear and type-safe result handling.</p>"},{"location":"usage/handling-results/#understanding-dbresult-and-dbqueryresult","title":"Understanding <code>DBResult</code> and <code>DBQueryResult</code>","text":"<p>Most Ommi operations that interact with the database (e.g., adding a record, finding one or more records) don't return the raw data or raise an exception directly. Instead, they typically return an awaitable object that, when awaited, resolves to either a <code>DBResult</code> or a <code>DBQueryResult</code> instance.</p> <p>These result types are wrappers around the actual outcome and have two main variants:</p> <ul> <li><code>DBSuccess[T]</code> (or <code>DBQuerySuccess[T]</code>): Indicates the operation was successful and contains the result of type <code>T</code>.<ul> <li>For example, <code>T</code> could be your model instance for <code>db.find(...).one()</code>, a list or iterator of models for <code>db.find(...).all()</code>, an integer for <code>db.find(...).count()</code>, or the added model for <code>db.add(...)</code>.</li> </ul> </li> <li><code>DBFailure[T]</code> (or <code>DBQueryFailure[T]</code>): Indicates the operation failed and contains the <code>Exception</code> that occurred.</li> </ul> <p>Both <code>DBResult</code> and <code>DBQueryResult</code> (and their success/failure variants) support the <code>result_or(default_value)</code> method and can be used effectively with <code>match/case</code>.</p>"},{"location":"usage/handling-results/#using-matchcase-for-result-handling","title":"Using <code>match/case</code> for Result Handling","text":"<p>Python's structural pattern matching (<code>match/case</code>) is a powerful way to handle these result types.</p>"},{"location":"usage/handling-results/#example-fetching-a-single-record-with-dbfindone","title":"Example: Fetching a Single Record with <code>db.find(...).one</code>","text":"<p>When you use <code>db.find(...).one</code>, the operation might succeed (record found) or fail (record not found, or other database error).</p> <pre><code>import asyncio\nfrom dataclasses import dataclass\nfrom typing import Optional, Annotated\n\nfrom ommi import Ommi, ommi_model\nfrom ommi.models.field_metadata import Key\nfrom ommi.ext.drivers.sqlite import SQLiteDriver\nfrom ommi.database import DBResult # For type hinting, DBSuccess/DBFailure are accessed via DBResult\n# from ommi.database import DBQueryResult # If specifically handling find results\n\n@ommi_model()\n@dataclass\nclass User:\n    id: Annotated[int, Key]\n    name: str\n\nasync def get_user_by_id(db: Ommi, user_id: int) -&gt; Optional[User]:\n    # The .one itself returns an awaitable that resolves to DBResult or DBQueryResult\n    # For clarity, we can await it to get the actual result object.\n    query_operation = db.find(User.id == user_id).one\n    result_status: DBResult[User] = await query_operation # Await the operation to get the status object\n\n    match result_status:\n        case DBResult.DBSuccess(user_instance): # Matches if successful, extracts the User instance\n            print(f\"Successfully fetched user: {user_instance.name}\")\n            return user_instance\n        case DBResult.DBFailure(exception):\n            # DBStatusNoResultException is common if .one finds nothing\n            if isinstance(exception, DBResult.DBStatusNoResultException): # Assuming this specific exception type\n                print(f\"User with ID {user_id} not found.\")\n            else:\n                print(f\"Error fetching user {user_id}: {type(exception).__name__} - {exception}\")\n            return None\n        case _:\n            print(\"Unhandled result status.\") # Should not happen with DBResult\n            return None\n\nasync def main():\n    driver = SQLiteDriver.connect()\n    async with Ommi(driver) as db:\n        await db.add(User(id=1, name=\"Alice\")).or_raise()\n\n        user = await get_user_by_id(db, 1)\n        if user:\n            print(f\"Main found: {user.name}\")\n\n        user_not_found = await get_user_by_id(db, 2)\n        if not user_not_found:\n            print(\"Main confirmed: User 2 not found.\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Explanation:</p> <ul> <li><code>query_operation = db.find(User.id == user_id).one</code> creates the awaitable query part.</li> <li><code>result_status: DBResult[User] = await query_operation</code> executes the query and gives you the <code>DBResult</code> object (which could be <code>DBSuccess</code> or <code>DBFailure</code>).</li> <li><code>case DBResult.DBSuccess(user_instance)</code>: If the query was successful and a user was found, this case matches. The <code>user_instance</code> variable is automatically assigned the <code>User</code> object from <code>DBSuccess.result</code>.</li> <li><code>case DBResult.DBFailure(exception)</code>: If any error occurred (including not finding a record with <code>.one</code>), this case matches. The <code>exception</code> variable holds the exception instance. You can then inspect the type of exception.<ul> <li>Note: The exact exception type for \"not found\" by <code>.one()</code> would be <code>ommi.database.results.DBStatusNoResultException</code> (or similar, based on the imports in your <code>query_results.py</code>).</li> </ul> </li> </ul>"},{"location":"usage/handling-results/#example-adding-a-record-with-dbadd","title":"Example: Adding a Record with <code>db.add</code>","text":"<p>The <code>db.add()</code> operation also returns a <code>DBResult</code>.</p> <pre><code># (Assuming User model and imports from previous example)\n\nasync def add_new_user(db: Ommi, user_id: int, name: str):\n    new_user = User(id=user_id, name=name)\n    add_operation = db.add(new_user) # add() returns an awaitable\n    result_status: DBResult[User] = await add_operation\n\n    match result_status:\n        case DBResult.DBSuccess(added_user): # Contains the model instance that was added\n            print(f\"Successfully added user: {added_user.name} (ID: {added_user.id})\")\n            return added_user\n        case DBResult.DBFailure(exception):\n            print(f\"Error adding user {name}: {type(exception).__name__} - {exception}\")\n            # e.g., could be a constraint violation if ID already exists and is a PK\n            return None\n\nasync def main_add():\n    driver = SQLiteDriver.connect()\n    async with Ommi(driver) as db:\n        user_bob = await add_new_user(db, 2, \"Bob\")\n        if user_bob:\n            # Attempt to add again, which might cause a PK constraint error\n            await add_new_user(db, 2, \"Bobby\") # This will likely print an error\n\n# if __name__ == \"__main__\":\n#     asyncio.run(main_add())\n</code></pre>"},{"location":"usage/handling-results/#using-result_ordefault_value","title":"Using <code>result_or(default_value)</code>","text":"<p>If you simply want to get the result or a default value if the operation fails (or, in some cases, if no result is found), the <code>result_or(default)</code> method is very convenient.</p> <p><pre><code># (Assuming User model and imports from previous example)\n\nasync def get_user_or_default(db: Ommi, user_id: int) -&gt; User:\n    default_user = User(id=-1, name=\"Default User\")\n    query_operation = db.find(User.id == user_id).one\n    user_instance_or_default = (await query_operation).result_or(default_user)\n\n    # Note: If .one() fails due to a non-DBStatusNoResultException (e.g., DB connection issue),\n    # result_or() would still return the default if the overall result is a DBFailure.\n    # If the operation yields DBSuccess but with an empty result (not typical for .one but for .all), behavior depends on T.\n\n    if user_instance_or_default.id == -1:\n        print(f\"User {user_id} not found, using default.\")\n    else:\n        print(f\"Found user {user_id}: {user_instance_or_default.name}\")\n    return user_instance_or_default\n\nasync def main_result_or():\n    driver = SQLiteDriver.connect()\n    async with Ommi(driver) as db:\n        await db.add(User(id=3, name=\"Charlie\")).or_raise()\n        await get_user_or_default(db, 3)\n        await get_user_or_default(db, 4) # Will use default\n\n# if __name__ == \"__main__\":\n#     asyncio.run(main_result_or())\n</code></pre> When <code>result_or</code> is useful: *   When you have a sensible default to fall back to. *   When you want to avoid <code>match/case</code> for simpler scenarios where you don't need detailed error inspection.</p> <p>Important Note on <code>.one.result_or(default)</code>: If <code>db.find(...).one</code> fails to find a record, it results in a <code>DBFailure</code> containing a <code>DBStatusNoResultException</code>. In this case, <code>(await query_operation).result_or(default)</code> will correctly return your <code>default</code>.</p>"},{"location":"usage/handling-results/#comparison-with-or_raise-and-or_else","title":"Comparison with <code>.or_raise()</code> and <code>.or_else()</code>","text":"<ul> <li> <p><code>.or_raise()</code>: Awaits the operation and if it's a failure (any <code>DBFailure</code> or <code>DBQueryFailure</code>), it raises the contained exception. This is concise if you want exceptions to propagate and be handled by a higher-level <code>try/except</code>.</p> </li> <li> <p><code>.or_else(default_value)</code> (or similar, e.g. <code>.or_use(default_value)</code> seen in <code>WrapInResult</code>): This is a common alternative name for functionality similar to <code>result_or</code>. Ommi provides <code>result_or(default)</code> directly on the <code>DBResult</code>/<code>DBQueryResult</code> objects after they have been awaited.     The <code>LazyQueryField</code> in <code>ommi.models.query_fields</code> shows an <code>async def or_use[D](self, default: D)</code> method, which internally calls <code>(await self.get_result()).result_or(default)</code>. This provides a convenient shortcut on the lazy field itself.</p> </li> <li> <p><code>match/case</code>: Offers the most explicit control. You can distinguish between different types of failures, log specific errors, or take different actions based on the success or failure details.</p> </li> <li> <p><code>(await operation).result_or(default)</code>: Good for providing a fallback value without detailed error handling logic.</p> </li> </ul> <p>Choose the method that best fits the clarity and error handling requirements of your specific situation.</p>"},{"location":"usage/handling-results/#results-of-all-operations","title":"Results of <code>.all()</code> operations","text":"<p>When you use an operation like <code>db.find(...).all()</code>, the <code>DBQuerySuccess</code> variant will typically contain an iterable (like <code>AsyncBatchIterator[YourModel]</code>) as its result. You can then iterate over this.</p> <pre><code># (Assuming User model and imports)\nasync def get_all_users(db: Ommi):\n    find_all_op = db.find(User).all() # This builder itself is awaitable or has awaitable methods\n    result_status: DBQueryResult[AsyncBatchIterator[User]] = await find_all_op # Await the .all() builder\n\n    match result_status:\n        case DBQueryResult.DBQuerySuccess(users_iterator):\n            print(\"Successfully fetched users:\")\n            users_found = False\n            async for user in users_iterator:\n                users_found = True\n                print(f\"- {user.name}\")\n            if not users_found:\n                print(\"(No users found in the database)\")\n        case DBQueryResult.DBQueryFailure(exception):\n            print(f\"Error fetching all users: {exception}\")\n\n# ... (main function to test this)\n</code></pre> <p>By understanding and utilizing <code>DBResult</code>, <code>DBQueryResult</code>, <code>match/case</code>, and <code>result_or</code>, you can write more resilient and expressive database interaction code with Ommi. </p>"},{"location":"usage/lazy-fields/","title":"Understanding Lazy Fields (Query Fields)","text":"<p>Ommi handles lazy loading of related data through a powerful feature called Query Fields. These allow you to define model attributes that represent relationships to other models. The data for these related models is not fetched immediately when the parent object is loaded; instead, it's retrieved (lazily) only when you explicitly <code>await</code> the query field attribute.</p> <p>This approach is excellent for:</p> <ul> <li>Performance: Avoiding the overhead of complex joins and loading large related object graphs by default.</li> <li>Clarity: Defining relationships directly within your models using expressive type annotations. Ommi infers the join conditions from <code>ReferenceTo</code> annotations on your foreign key fields.</li> </ul>"},{"location":"usage/lazy-fields/#types-of-query-fields-for-lazy-loading","title":"Types of Query Fields for Lazy Loading","text":"<p>Ommi provides specialized types within <code>ommi.models.query_fields</code> to define different kinds of lazy-loaded relationships:</p> <ul> <li><code>LazyLoadTheRelated[TargetModelType]</code>: For one-to-one or many-to-one relationships. When awaited, it fetches a single instance of <code>TargetModelType</code> or <code>None</code>.</li> <li><code>LazyLoadEveryRelated[TargetModelType]</code>: For one-to-many or many-to-many relationships. When awaited, it fetches a list of <code>TargetModelType</code> instances.</li> </ul> <p>These types are typically used in conjunction with <code>typing.Annotated</code> and <code>ommi.models.field_metadata.ReferenceTo</code> (for foreign keys). For many-to-many relationships, <code>ommi.models.query_fields.AssociateUsing</code> is also involved, as shown in the Association Tables guide.</p>"},{"location":"usage/lazy-fields/#defining-and-using-lazy-fields","title":"Defining and Using Lazy Fields","text":"<p>Here's how you can define and use lazy-loaded query fields:</p>"},{"location":"usage/lazy-fields/#1-one-to-one-many-to-one-relationships","title":"1. One-to-One / Many-to-One Relationships","text":"<p>Imagine a <code>Comment</code> model that relates to a single <code>Article</code>. Ommi will infer how to join <code>Comment</code> to <code>Article</code> based on the <code>article_id</code> field having a <code>ReferenceTo(Article)</code> annotation.</p> <pre><code>import asyncio\nfrom dataclasses import dataclass\nfrom typing import Annotated, Optional\n\nfrom ommi import Ommi, ommi_model\nfrom ommi.models.collections import ModelCollection\nfrom ommi.models.field_metadata import ReferenceTo\nfrom ommi.models.query_fields import LazyLoadTheRelated\n# `when` is not needed for basic inferred joins but useful for custom queries.\n# from ommi.query_ast import when\nfrom ommi.ext.drivers.sqlite import SQLiteDriver # Example driver\n\napp_models = ModelCollection()\n\n@ommi_model(collection=app_models)\n@dataclass\nclass Article:\n    id: int\n    title: str\n\n@ommi_model(collection=app_models)\n@dataclass\nclass Comment:\n    id: int\n    text: str\n    # This field provides the link for Ommi to infer the join for `article` query field.\n    article_id: Annotated[int, ReferenceTo(Article)] # Foreign Key to Article\n\n    # Query field to lazily load the related Article.\n    # Ommi infers the join condition using `article_id` and its `ReferenceTo(Article)`.\n    article: \"LazyLoadTheRelated[Article]\"\n\n\nasync def demo_one_to_one_lazy_load():\n    driver = SQLiteDriver.connect() # In-memory SQLite for example\n    async with Ommi(driver) as db:\n        await app_models.setup_on(db)\n\n        # Create sample data\n        article_1 = Article(id=1, title=\"Understanding Ommi\")\n        comment_1 = Comment(id=101, text=\"Great article!\", article_id=article_1.id)\n        await db.add(article_1, comment_1).or_raise()\n\n        # Fetch a comment\n        retrieved_comment = await db.find(Comment.id == 101).one.or_raise()\n        print(f\"Comment: '{retrieved_comment.text}' (Article ID: {retrieved_comment.article_id})\")\n\n        # At this point, `retrieved_comment.article` has not been loaded from the DB.\n        # To load it, await the query field:\n        print(\"Lazily loading related article...\")\n        related_article_instance = await retrieved_comment.article\n\n        if related_article_instance:\n            print(f\"Belongs to Article (loaded lazily): '{related_article_instance.title}' (ID: {related_article_instance.id})\")\n        else:\n            print(\"Could not load related article.\")\n\n        await app_models.remove_from(db)\n\n# To run:\n# if __name__ == \"__main__\":\n#     asyncio.run(demo_one_to_one_lazy_load())\n</code></pre>"},{"location":"usage/lazy-fields/#2-one-to-many-relationships","title":"2. One-to-Many Relationships","text":"<p>An <code>Article</code> can have multiple <code>Comment</code>s. Ommi infers this relationship by finding <code>Comment</code> models that have a foreign key (<code>article_id</code>) pointing back to the <code>Article</code>.</p> <pre><code># (Continuing from previous example, ensure Article and Comment models are defined)\n# Ensure necessary imports are present: LazyLoadEveryRelated\n# from ommi.models.query_fields import LazyLoadEveryRelated\n\n@ommi_model(collection=app_models) # Assuming app_models and Comment are already defined\n@dataclass\nclass Article:\n    id: int\n    title: str\n\n    # Query field to lazily load all related Comments for this Article.\n    # Ommi infers that it needs to find Comments where Comment.article_id == self.id\n    # based on the ReferenceTo(Article) in the Comment model.\n    comments: \"LazyLoadEveryRelated[Comment]\"\n\n\nasync def demo_one_to_many_lazy_load():\n    driver = SQLiteDriver.connect()\n    async with Ommi(driver) as db:\n        await app_models.setup_on(db) # Ensure tables for Article, Comment exist\n\n        # Create sample data\n        article_2 = Article(id=2, title=\"Ommi Query Fields\")\n        # Ensure Comment is defined as in the previous example for this to work seamlessly\n        comment_2a = Comment(id=201, text=\"Very cool!\", article_id=article_2.id)\n        comment_2b = Comment(id=202, text=\"Super useful.\", article_id=article_2.id)\n        comment_2c = Comment(id=203, text=\"Needs more examples.\", article_id=999) # Unrelated comment\n\n        await db.add(article_2, comment_2a, comment_2b, comment_2c).or_raise()\n\n        # Fetch an article\n        retrieved_article = await db.find(Article.id == 2).one.or_raise()\n        print(f\"Article: '{retrieved_article.title}'\")\n\n        # Load its comments lazily\n        print(\"Lazily loading comments...\")\n        related_comments_list = await retrieved_article.comments\n\n        print(f\"Found {len(related_comments_list)} comments for '{retrieved_article.title}' (loaded lazily):\")\n        for c in related_comments_list:\n            print(f\"- '{c.text}' (ID: {c.id}, ArticleID: {c.article_id})\")\n\n        await app_models.remove_from(db)\n\n# To run:\n# if __name__ == \"__main__\":\n#     asyncio.run(demo_one_to_many_lazy_load())\n</code></pre>"},{"location":"usage/lazy-fields/#how-it-works","title":"How it Works","text":"<p>When you define an attribute like <code>article: \"LazyLoadTheRelated[Article]\"</code> on your <code>Comment</code> model:</p> <ol> <li>Ommi recognizes this as a query field during model processing.</li> <li>It inspects the <code>Comment</code> model for fields that have a <code>ReferenceTo(Article)</code> annotation (in this case, <code>Comment.article_id</code>).</li> <li>This foreign key relationship informs Ommi how to construct the query to fetch the related <code>Article</code> for a given <code>Comment</code> instance (i.e., <code>WHERE Article.id == comment_instance.article_id</code>).</li> <li>When an instance of <code>Comment</code> is created, the <code>article</code> attribute becomes an instance of <code>LazyLoadTheRelated</code>.</li> <li>This object holds the context needed (like the parent <code>Comment</code> instance's ID and the inferred join condition) and has access to the database driver.</li> <li>When you <code>await</code> this attribute (e.g., <code>await retrieved_comment.article</code>), it executes the inferred query to fetch the related <code>Article</code> data.</li> </ol> <p>A similar process occurs for <code>LazyLoadEveryRelated[Comment]</code> on the <code>Article</code> model, where Ommi looks for <code>Comment</code> models referencing the <code>Article</code>.</p> <p>This inference mechanism provides a clean and Pythonic way to declare and use lazily-loaded relationships, minimizing explicit query definitions for common relationship patterns.</p>"},{"location":"usage/lazy-fields/#considerations","title":"Considerations","text":"<ul> <li><code>ReferenceTo</code> is Key: The accuracy of your <code>ReferenceTo</code> annotations on foreign key fields is crucial for Ommi to correctly infer the join conditions.</li> <li>Async Await: Remember that accessing the data from a query field is an asynchronous operation, so you must <code>await</code> it.</li> <li>N+1 Problem: If you iterate over a list of objects and <code>await</code> a query field for each one inside the loop, you will issue multiple database queries (N+1). If you need to load related data for many objects at once, look for mechanisms in Ommi that might allow for eager loading or prefetching these relationships (this specific feature for optimizing N+1 is not detailed in the reviewed test files but is common in ORMs).</li> </ul> <p>Next, see how this simplified approach applies to Association Tables for many-to-many relationships, where <code>AssociateUsing</code> helps guide the inference. </p>"},{"location":"usage/model-collections/","title":"Using Explicit Model Collections","text":"<p>By default, Ommi automatically manages the database schema for models defined with <code>@ommi_model()</code> that are not assigned to a specific collection (these effectively belong to an implicit, global setup). However, for more structured applications, using explicit <code>ModelCollection</code> instances provides greater control over model grouping and schema management.</p>"},{"location":"usage/model-collections/#why-use-explicit-model-collections","title":"Why Use Explicit Model Collections?","text":"<ul> <li>Modularity: Group related models for different features or domains.</li> <li>Granular Schema Management: Set up or tear down tables for specific model groups independently using <code>await db.use_models(your_collection)</code>.</li> <li>Testing: Easily manage schemas for specific test suites.</li> <li>Clarity: Clearly define which models belong together.</li> </ul>"},{"location":"usage/model-collections/#how-to-use-explicit-model-collections","title":"How to Use Explicit Model Collections","text":"<ol> <li>Import <code>ModelCollection</code>: From <code>ommi.models.collections</code>.</li> <li>Instantiate Collections: Create one or more <code>ModelCollection</code> instances (e.g., <code>core_models = ModelCollection()</code>, <code>feature_models = ModelCollection()</code>).</li> <li>Assign Models: Use <code>@ommi_model(collection=your_collection_instance)</code> to associate models with an explicit collection.</li> <li>Manage Schema via <code>Ommi</code> instance: Use <code>await db.use_models(your_collection_instance)</code> to create tables for that collection and <code>await db.remove_models(your_collection_instance)</code> to remove them.</li> </ol>"},{"location":"usage/model-collections/#example","title":"Example","text":"<pre><code>import asyncio\nfrom dataclasses import dataclass\nfrom typing import Optional, Annotated\n\nfrom ommi import Ommi, ommi_model\nfrom ommi.models.collections import ModelCollection\nfrom ommi.models.field_metadata import Key, Auto\nfrom ommi.ext.drivers.sqlite import SQLiteDriver\n\n# 1. Instantiate explicit collections\ncore_app_models = ModelCollection()\nblog_feature_models = ModelCollection()\n\n# --- Models assigned to core_app_models ---\n@ommi_model(collection=core_app_models)\n@dataclass\nclass User:\n    id: Annotated[int, Key | Auto]\n    username: str\n\n# --- Models assigned to blog_feature_models ---\n@ommi_model(collection=blog_feature_models)\n@dataclass\nclass BlogPost:\n    post_id: Annotated[int, Key | Auto]\n    title: str\n    author_id: int # FK to User.id\n\n# --- A model NOT in an explicit collection (part of Ommi's default/global setup) ---\n@ommi_model()\n@dataclass\nclass LogEntry:\n    log_id: Annotated[int, Key | Auto]\n    message: str\n\nasync def manage_collections_example():\n    driver = SQLiteDriver.connect()\n    async with Ommi(driver) as db:\n        # Ommi automatically handles schema for LogEntry (default/global setup)\n        # For explicit collections, we call db.use_models() with the collection:\n        print(\"Setting up tables for core_app_models...\")\n        await db.use_models(core_app_models)\n\n        print(\"Setting up tables for blog_feature_models...\")\n        await db.use_models(blog_feature_models)\n\n        print(\"Explicit collection tables created. Default model tables (LogEntry) managed automatically.\")\n\n        # Add some data\n        await db.add(User(username=\"core_user\")).or_raise()\n        await db.add(BlogPost(title=\"My Blog Post\", author_id=1)).or_raise() # Assuming User ID 1 exists\n        await db.add(LogEntry(message=\"Application started\")).or_raise()\n\n        print(f\"User count: {await db.find(User).count.or_raise()}\")\n        print(f\"BlogPost count: {await db.find(BlogPost).count.or_raise()}\")\n        print(f\"LogEntry count: {await db.find(LogEntry).count.or_raise()}\")\n\n        # Teardown for explicit collections\n        print(\"Removing tables for blog_feature_models...\")\n        await db.remove_models(blog_feature_models)\n\n        print(\"Removing tables for core_app_models...\")\n        await db.remove_models(core_app_models)\n\n        # Tables for LogEntry (default/global) would remain if DB is persistent,\n        # or be gone if DB is in-memory and connection is closed.\n\n        print(\"Explicit collection tables removed.\")\n\nif __name__ == \"__main__\":\n    asyncio.run(manage_collections_example())\n</code></pre>"},{"location":"usage/model-collections/#key-takeaways","title":"Key Takeaways","text":"<ul> <li><code>@ommi_model(collection=...)</code>: Assigns a model to an explicit collection.</li> <li><code>await db.use_models(your_collection)</code>: Essential for creating tables for models within an explicit collection.</li> <li><code>await db.remove_models(your_collection)</code>: Removes tables for an explicit collection.</li> <li>Automatic Handling for Default Models: Models defined with <code>@ommi_model()</code> (no <code>collection</code>) have their schema managed implicitly by Ommi. You do not call <code>db.use_models()</code> without arguments for this purpose.</li> <li>Mixing: You can have some models in explicit collections and others handled by Ommi's default mechanism within the same application.</li> </ul> <p>Explicit model collections give you precise control when your project's complexity grows. </p>"},{"location":"usage/models/","title":"Working with Models","text":"<p>Ommi primarily uses Python <code>dataclasses</code> decorated with <code>@ommi_model</code> to define your data structures. When you define models this way without assigning them to a specific collection, Ommi automatically manages their database schema (e.g., creating tables when they are first used or when the Ommi instance initializes).</p> <p>While Ommi is built with dataclasses in mind, its flexibility might allow for other model types if they can be adapted to Ommi's introspection mechanisms. However, the standard and tested approach is to use <code>@ommi_model</code> with <code>@dataclass</code>.</p>"},{"location":"usage/models/#defining-models-default-automatic-schema-management","title":"Defining Models (Default Automatic Schema Management)","text":"<p>You define your data structures using <code>@dataclass</code> and then decorate them with <code>@ommi_model()</code>. These models are implicitly part of a default setup managed by Ommi.</p> <pre><code>import asyncio\nfrom dataclasses import dataclass\nfrom typing import Optional, Annotated\n\nfrom ommi import Ommi, ommi_model\nfrom ommi.models.field_metadata import Key, Auto, StoreAs\nfrom ommi.ext.drivers.sqlite import SQLiteDriver\n\n# Models defined with @ommi_model() are automatically managed by Ommi regarding their schema.\n@ommi_model()\n@dataclass\nclass Product:\n    product_id: Annotated[int, Key | Auto]\n    name: str\n    description: Optional[str] = None\n    price: float\n    stock_count: int = 0\n\n@ommi_model()\n@dataclass\nclass Customer:\n    customer_id: Annotated[int, Key]\n    first_name: str\n    last_name: str\n    email: str\n    created_at: Annotated[str, StoreAs(\"registration_date\")]\n\nasync def setup_and_use_models():\n    driver = SQLiteDriver.connect()\n    async with Ommi(driver) as db:\n        # No explicit schema setup call is needed here for these default models.\n        # Ommi handles their schema automatically.\n        print(\"Product and Customer tables will be managed automatically by Ommi.\")\n\n        new_product = Product(product_id=1, name=\"Laptop\", price=1200.00, stock_count=50)\n        await db.add(new_product).or_raise()\n        print(f\"Added product: {new_product}\")\n\n        retrieved_product = await db.find(Product.product_id == 1).one.or_raise()\n        print(f\"Found: {retrieved_product}\")\n\n        await db.find(Product.product_id == 1).update(price=1150.00, stock_count=45).or_raise()\n        updated_product = await db.find(Product.product_id == 1).one.or_raise()\n        print(f\"Updated: {updated_product}\")\n\n        available_count = await db.find(Product.stock_count &gt; 0).count.or_raise()\n        print(f\"Products available: {available_count}\")\n\n        # Teardown for automatically managed tables depends on DB &amp; driver.\n        # In-memory SQLite tables are gone when connection closes.\n\n# if __name__ == \"__main__\":\n#     asyncio.run(setup_and_use_models())\n</code></pre> <p>Key Points for Model Definition:</p> <ul> <li><code>@ommi_model()</code>: Decorates your dataclass. Without a <code>collection</code> argument, Ommi handles its schema implicitly.</li> <li><code>@dataclass</code>: Standard for field definitions.</li> <li>Type Hinting &amp; Metadata (<code>typing.Annotated</code>): For database-specific properties like <code>Key</code>, <code>Auto</code>, <code>StoreAs</code>, <code>ReferenceTo</code> from <code>ommi.models.field_metadata</code>. Combine using <code>|</code>.</li> <li>Automatic Schema Handling (Default): For models not assigned to an explicit collection, Ommi manages table creation/updates automatically. You don't need to call explicit setup functions for them.</li> <li>Explicit Model Collections: For more control, use explicit <code>ModelCollection</code> instances. These require <code>await db.use_models(your_collection)</code> for schema setup. (See the Model Collections tutorial).</li> </ul>"},{"location":"usage/models/#using-models-with-ommi","title":"Using Models with <code>Ommi</code>","text":"<p>Once your models are defined and their tables created via <code>collection.setup_on(db)</code>:</p> <ul> <li>Adding Objects: <code>await db.add(YourModel(...)).or_raise()</code></li> <li>Finding Objects: <code>await db.find(YourModel.field == value).one.or_raise()</code> (for a single object) or <code>await db.find(...).or_raise()</code> (for multiple, then iterate asynchronously).</li> <li>Updating Objects: <code>await db.find(YourModel.field == value).update(new_field_value=...).or_raise()</code></li> <li>Deleting Objects: <code>await db.find(YourModel.field == value).delete.or_raise()</code></li> <li>Counting Objects: <code>await db.find(YourModel.field == value).count.or_raise()</code></li> </ul> <p>All interactions are asynchronous and utilize the <code>Ommi</code> instance (<code>db</code>). The <code>.or_raise()</code> method is commonly used to raise an exception if the operation fails or finds no results (for <code>.one</code>).</p> <p>Next, learn about Lazy Fields (Query Fields), which also work with these automatically managed models. </p>"}]}